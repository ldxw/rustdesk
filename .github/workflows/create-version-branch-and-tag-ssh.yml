name: 更新分支并打Tag：子模块 + URL替换 + Tag锚定分支HEAD

on:
  workflow_dispatch:
    inputs:
      work_branch:
        description: "要更新并打Tag的分支（例如 1.4.2）"
        required: true
        default: "1.4.2"
      admin_url:
        description: "替换 https://admin.rustdesk.com 为该地址"
        required: true
        default: "https://admin-hy.rs.ldxw.top"
      submodule_url:
        description: "libs/hbb_common 子模块HTTPS地址"
        required: true
        default: "https://github.com/ldxw/rustdesk_hbb_common.git"
      submodule_branch:
        description: "libs/hbb_common 子模块分支（auto自动检测）"
        required: true
        default: "auto"
      push_branch:
        description: "是否推送分支到远端"
        type: choice
        options: ["true", "false"]
        required: true
        default: "true"
      force:
        description: "是否强制推分支/打Tag"
        type: choice
        options: ["false", "true"]
        required: true
        default: "false"
      do_tag:
        description: "是否在分支HEAD打Tag"
        type: choice
        options: ["true", "false"]
        required: true
        default: "true"
      version:
        description: "Tag名（留空用分支名）"
        required: false
        default: ""
      tag_message:
        description: "Tag注释"
        required: false
        default: "修改内置服务器和 key"
      retag:
        description: "是否先删旧Tag再建"
        type: choice
        options: ["true", "false"]
        required: true
        default: "true"

permissions:
  contents: write

jobs:
  update_and_tag:
    runs-on: ubuntu-latest
    env:
      WORK_BRANCH: ${{ inputs.work_branch }}
      TARGET_FILE: "flutter/lib/desktop/pages/connection_page.dart"
    steps:
      # 步骤1：拉取代码（完整历史）
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      # 步骤2：配置Git身份
      - name: Set Git identity
        run: |
          set -euo pipefail
          echo "===== 执行步骤2：配置Git身份 ====="
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      # 步骤3：准备本地分支
      - name: Prepare local branch
        run: |
          set -euo pipefail
          echo "===== 执行步骤3：准备本地分支 ====="
          git fetch origin --no-tags
          
          # 校验远端分支
          if ! git show-ref --verify --quiet "refs/remotes/origin/${WORK_BRANCH}"; then
            echo "::error::远端无 origin/${WORK_BRANCH} 分支"
            exit 1
          fi
          
          # 切换/创建分支
          if git show-ref --verify --quiet "refs/heads/${WORK_BRANCH}"; then
            git checkout "${WORK_BRANCH}"
            git merge --ff-only "origin/${WORK_BRANCH}" || { echo "::error::分支冲突"; exit 1; }
          else
            git checkout -B "${WORK_BRANCH}" "origin/${WORK_BRANCH}"
          fi

      # 步骤4：配置子模块
      - name: Configure submodule
        run: |
          set -euo pipefail
          echo "===== 执行步骤4：配置子模块 ====="
          SM_PATH="libs/hbb_common"
          SM_URL="${{ inputs.submodule_url }}"
          REQ_BRANCH="${{ inputs.submodule_branch }}"
          
          # 校验.gitmodules
          if [ ! -f .gitmodules ]; then
            echo "::error::无 .gitmodules 文件"
            exit 1
          fi
          
          # 自动检测子模块分支
          DETECTED_BRANCH="$REQ_BRANCH"
          if [ "$REQ_BRANCH" = "auto" ] || ! git ls-remote --heads "${SM_URL}" "${REQ_BRANCH}" | grep -q .; then
            DETECTED_BRANCH=$(git ls-remote --symref "${SM_URL}" HEAD | awk '/^ref:/ {print $2}' | sed 's#refs/heads/##')
            [ -z "${DETECTED_BRANCH}" ] && { echo "::error::子模块无默认分支"; exit 1; }
          fi
          
          # 更新子模块配置并拉取
          git config -f .gitmodules "submodule.${SM_PATH}.url" "${SM_URL}"
          git config -f .gitmodules "submodule.${SM_PATH}.branch" "${DETECTED_BRANCH}"
          [ ! -z "$(git diff .gitmodules)" ] && git commit -m "chore: update submodule config"
          
          git submodule sync -- "${SM_PATH}"
          git submodule update --init --remote "${SM_PATH}"
          git -C "${SM_PATH}" checkout -B "${DETECTED_BRANCH}" "origin/${DETECTED_BRANCH}"
          [ ! -z "$(git diff "${SM_PATH}")" ] && git commit -m "chore: bump submodule"

      # 步骤5：替换admin地址
      - name: Replace admin URL
        run: |
          set -euo pipefail
          echo "===== 执行步骤5：替换admin地址 ====="
          OLD_URL="https://admin.rustdesk.com"
          NEW_URL="${{ inputs.admin_url }}"
          NEW_URL_ESC="${NEW_URL//&/\\&}"
          
          # 批量替换
          FILES=$(git grep -l -E "${OLD_URL//./\\.}" -- ':!:libs/hbb_common' || true)
          [ -n "${FILES}" ] && echo "${FILES}" | xargs -r sed -i -e "s|${OLD_URL}|${NEW_URL_ESC}|g"
          
          # 提交变更
          [ ! -z "$(git diff)" ] && git commit -m "chore: replace admin URL to ${NEW_URL}"

      # 步骤6：替换connection_page.dart代码
      - name: Replace target dart file
        run: |
          set -euo pipefail
          echo "===== 执行步骤6：替换dart文件 ====="
          
          # 校验文件
          if [ ! -f "${TARGET_FILE}" ]; then
            echo "::error::${TARGET_FILE} 不存在"
            exit 1
          fi
          
          # 生成新代码
          printf "%s\n" "Widget setupServerWidget() => Flexible(" \
                         "       child: Offstage(" \
                         "         offstage: !(!_svcStopped.value &&" \
                         "             stateGlobal.svcStatus.value == SvcStatus.ready &&" \
                         "             _svcIsUsingPublicServer.value)," \
                         "         child: Row(" \
                         "           crossAxisAlignment: CrossAxisAlignment.center," \
                         "           children: [],)," \
                         "       )," \
                         "     );" > /tmp/new_code.tmp
          
          # 替换代码
          sed -i '81,110d' "${TARGET_FILE}"
          sed -i '81r /tmp/new_code.tmp' "${TARGET_FILE}"
          rm -f /tmp/new_code.tmp
          
          # 提交变更
          [ ! -z "$(git diff "${TARGET_FILE}")" ] && git commit -m "chore: replace ${TARGET_FILE} 81-110 lines"

      # 步骤7：推送分支+存储远端SHA（关键：确保变量有值）
      - name: Push branch & save remote SHA
        if: ${{ inputs.push_branch == 'true' }}
        env:
          GH_TOKEN: ${{ secrets.REPO_WORKFLOW_PAT }}
        run: |
          set -euo pipefail
          echo "===== 执行步骤7：推送分支 ====="
          # 配置远端地址
          git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
          
          # 推送分支
          if [ "${{ inputs.force }}" = "true" ]; then
            git push --force-with-lease origin "${WORK_BRANCH}"
          else
            git push origin "${WORK_BRANCH}"
          fi
          
          # 强制获取远端SHA并存储（避免空值）
          REMOTE_BRANCH_SHA=$(git ls-remote origin "refs/heads/${WORK_BRANCH}" | awk '{print $1}')
          echo "REMOTE_BRANCH_SHA=${REMOTE_BRANCH_SHA}" >> "$GITHUB_ENV"
          echo "✅ 远端分支SHA：${REMOTE_BRANCH_SHA}"

      # 步骤8：打Tag+校验（修复空格语法+变量兜底）
      - name: Create & verify Tag
        if: ${{ inputs.do_tag == 'true' }}
        env:
          GH_TOKEN: ${{ secrets.REPO_WORKFLOW_PAT }}
        run: |
          set -euo pipefail
          echo "===== 执行步骤8：打Tag+校验 ====="
          # 1. 定义变量（避免空值）
          TAG="${{ inputs.version || env.WORK_BRANCH }}"
          TAG_MSG="${{ inputs.tag_message }}"
          LOCAL_SHA=$(git rev-parse "${WORK_BRANCH}^{commit}")
          # 变量兜底：未推分支时手动获取远端SHA
          REMOTE_BRANCH_SHA="${{ env.REMOTE_BRANCH_SHA }}"
          if [ -z "${REMOTE_BRANCH_SHA}" ]; then
            REMOTE_BRANCH_SHA=$(git ls-remote origin "refs/heads/${WORK_BRANCH}" | awk '{print $1}')
            [ -z "${REMOTE_BRANCH_SHA}" ] && { echo "::error::无法获取远端分支SHA"; exit 1; }
          fi
          
          # 2. 处理旧Tag
          git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
          if [ "${{ inputs.retag }}" = "true" ]; then
            git push origin ":refs/tags/${TAG}" || echo "ℹ️ 无旧Tag"
            git tag -d "${TAG}" 2>/dev/null || true
          fi
          
          # 3. 创建并推送Tag
          git tag -a "${TAG}" -m "${TAG_MSG}" "${LOCAL_SHA}"
          git push origin "refs/tags/${TAG}"
          echo "✅ 推送Tag：${TAG}（指向SHA：${LOCAL_SHA}）"
          
          # 4. 校验Tag（修复空格语法：去掉 ${TAG}^{ } 中的空格）
          REMOTE_TAG_SHA=$(git ls-remote --tags origin "refs/tags/${TAG}^{}" | awk '{print $1}')
          [ -z "${REMOTE_TAG_SHA}" ] && REMOTE_TAG_SHA=$(git ls-remote --tags origin "refs/tags/${TAG}" | awk '{print $1}')
          
          # 5. 校验Tag与分支同步
          if [ "${REMOTE_TAG_SHA}" != "${REMOTE_BRANCH_SHA}" ]; then
            echo "::error::Tag SHA(${REMOTE_TAG_SHA}) 与分支SHA(${REMOTE_BRANCH_SHA}) 不一致"
            exit 1
          fi
          echo "✅ Tag校验通过"

      # 步骤9：最终校验（无语法错误）
      - name: Final verification
        run: |
          set -euo pipefail
          echo "===== 执行步骤9：最终校验 ====="
          # 1. 分支信息
          echo -e "\n1. 本地分支信息"
          git show -s --format="  SHA：%H\n  说明：%s" "${WORK_BRANCH}"
          
          # 2. dart文件替换结果
          echo -e "\n2. Dart文件替换结果"
          grep -q "children: \[\]," "${TARGET_FILE}" && echo "  ✅ 替换成功" || echo "  ❗ 替换待核查"
          
          # 3. Tag信息
          if [ "${{ inputs.do_tag == 'true' }}" = "true" ]; then
            TAG="${{ inputs.version || env.WORK_BRANCH }}"
            echo -e "\n3. Tag信息"
            git tag -l "${TAG}" --format="  存在：%1.1s\n  注释：%(contents)"
          fi
          echo -e "\n===== 工作流执行完成 ====="
          
