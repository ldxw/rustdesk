name: 更新分支并打Tag：子模块 + URL替换 + Tag锚定分支HEAD

on:
  workflow_dispatch:
    inputs:
      work_branch:
        description: "要更新并打Tag的分支（例如 1.4.2）"
        required: true
        default: "1.4.2"
      admin_url:
        description: "替换 https://admin.rustdesk.com 为该地址（不改子模块）"
        required: true
        default: "https://admin-hy.rs.ldxw.top"
      submodule_url:
        description: "libs/hbb_common 子模块HTTPS仓库地址"
        required: true
        default: "https://github.com/ldxw/rustdesk_hbb_common.git"
      submodule_branch:
        description: "libs/hbb_common 子模块分支（auto=自动检测默认分支）"
        required: true
        default: "auto"
      push_branch:
        description: "是否将本地分支推送至远端"
        type: choice
        options: ["true", "false"]
        required: true
        default: "true"
      force:
        description: "推分支/打Tag是否用强制模式（谨慎选择）"
        type: choice
        options: ["false", "true"]
        required: true
        default: "false"
      do_tag:
        description: "是否在分支HEAD创建并推送Tag"
        type: choice
        options: ["true", "false"]
        required: true
        default: "true"
      version:
        description: "Tag名称（留空则自动使用目标分支名）"
        required: false
        default: ""
      tag_message:
        description: "Tag的说明注释"
        required: false
        default: "修改内置服务器和 key"
      retag:
        description: "若远端已存在同名Tag，是否先删除再创建"
        type: choice
        options: ["true", "false"]
        required: true
        default: "true"

# 授予工作流读写仓库权限，确保所有操作正常执行
permissions:
  contents: write

jobs:
  update_and_tag:
    runs-on: ubuntu-latest  # Ubuntu环境Git工具链完整，兼容性强
    env:
      WORK_BRANCH: ${{ inputs.work_branch }}  # 全局存储目标分支，避免重复引用
      TARGET_DART_FILE: "flutter/lib/desktop/pages/connection_page.dart"  # 全局存储目标Dart文件路径
    steps:
      # 步骤1：拉取仓库完整代码（含历史，不默认拉子模块）
      - name: Checkout repo (full history, no default submodule)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      # 步骤2：配置Git提交身份（避免无身份导致提交失败）
      - name: Set Git commit identity
        run: |
          set -euo pipefail
          echo "===== 执行步骤2：配置Git提交身份 ====="
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      # 步骤3：准备本地目标分支（同步远端，处理冲突）
      - name: Prepare local target branch
        run: |
          set -euo pipefail
          echo "===== 执行步骤3：准备本地目标分支 ====="
          git fetch origin --no-tags
          
          # 校验远端分支是否存在
          if ! git show-ref --verify --quiet "refs/remotes/origin/${WORK_BRANCH}"; then
            echo "::error::远端无 origin/${WORK_BRANCH} 分支，请确认分支名"
            exit 1
          fi
          
          # 切换/创建分支并同步远端
          if git show-ref --verify --quiet "refs/heads/${WORK_BRANCH}"; then
            git checkout "${WORK_BRANCH}"
            git merge --ff-only "origin/${WORK_BRANCH}" || {
              echo "::error::本地与远端分支冲突，需手动解决"
              exit 1
            }
            echo "✅ 本地分支 ${WORK_BRANCH} 已同步远端最新内容"
          else
            git checkout -B "${WORK_BRANCH}" "origin/${WORK_BRANCH}"
            echo "✅ 已从远端创建本地 ${WORK_BRANCH} 分支"
          fi

      # 步骤4：配置子模块（修复空值判断，避免成功却报错）
      - name: Configure submodule (libs/hbb_common)
        run: |
          set -euo pipefail
          echo "===== 执行步骤4：配置子模块 libs/hbb_common ====="
          SM_PATH="libs/hbb_common"
          SM_REPO_URL="${{ inputs.submodule_url }}"
          SM_REQUEST_BRANCH="${{ inputs.submodule_branch }}"
          
          # 校验子模块配置文件
          if [ ! -f .gitmodules ]; then
            echo "::error::未找到 .gitmodules 文件，无此子模块"
            exit 1
          fi
          
          # 自动检测子模块目标分支
          SM_TARGET_BRANCH="$SM_REQUEST_BRANCH"
          if [ "$SM_REQUEST_BRANCH" = "auto" ] || ! git ls-remote --heads "${SM_REPO_URL}" "${SM_REQUEST_BRANCH}" | grep -q .; then
            SM_TARGET_BRANCH=$(git ls-remote --symref "${SM_REPO_URL}" HEAD | awk '/^ref:/ {print $2}' | sed 's#refs/heads/##')
            [ -z "${SM_TARGET_BRANCH}" ] && { echo "::error::子模块无默认分支"; exit 1; }
            echo "✅ 子模块自动检测到默认分支：${SM_TARGET_BRANCH}"
          fi
          
          # 更新子模块配置并提交（仅当有修改时）
          git config -f .gitmodules "submodule.${SM_PATH}.url" "${SM_REPO_URL}"
          git config -f .gitmodules "submodule.${SM_PATH}.branch" "${SM_TARGET_BRANCH}"
          if ! git diff --quiet .gitmodules; then
            git add .gitmodules
            git commit -m "chore: update submodule ${SM_PATH} config"
            echo "✅ 已提交子模块配置更新"
          else
            echo "ℹ️ 子模块配置已为目标值，无需提交"
          fi
          
          # 同步子模块并拉取最新代码
          git submodule sync -- "${SM_PATH}"
          git submodule update --init --remote "${SM_PATH}"
          echo "✅ 子模块已克隆并拉取 ${SM_TARGET_BRANCH} 最新代码"
          
          # 子模块切换分支并与远端同步
          git -C "${SM_PATH}" fetch origin --no-tags
          git -C "${SM_PATH}" checkout -B "${SM_TARGET_BRANCH}" "origin/${SM_TARGET_BRANCH}"
          git -C "${SM_PATH}" reset --hard "origin/${SM_TARGET_BRANCH}"
          echo "✅ 子模块已切换到 ${SM_TARGET_BRANCH} 分支（与远端同步）"
          
          # 更新主仓库子模块指针（仅当有变更时）
          if ! git diff --quiet "${SM_PATH}"; then
            git add "${SM_PATH}"
            git commit -m "chore: bump submodule ${SM_PATH} to latest commit"
            echo "✅ 已提交主仓库子模块指针更新"
          else
            echo "ℹ️ 子模块指针已指向最新提交，无需更新"
          fi

      # 步骤5：替换admin HTTPS地址（仅主仓库，排除子模块）
      - name: Replace admin HTTPS URL (exclude submodule)
        run: |
          set -euo pipefail
          echo "===== 执行步骤5：替换admin HTTPS地址 ====="
          OLD_ADMIN_URL="https://admin.rustdesk.com"
          NEW_ADMIN_URL="${{ inputs.admin_url }}"
          NEW_URL_ESCAPED="${NEW_ADMIN_URL//&/\\&}"  # 转义&符号，避免sed报错
          
          # 预览替换前匹配结果
          echo "==> 替换前：匹配 ${OLD_ADMIN_URL} 的内容（前80行）"
          (git grep -n -E "${OLD_ADMIN_URL//./\\.}" -- ':!:libs/hbb_common' || echo "ℹ️ 未找到匹配内容") | head -n 80
          
          # 批量替换文件
          FILES_TO_REPLACE=$(git grep -l -E "${OLD_ADMIN_URL//./\\.}" -- ':!:libs/hbb_common' || true)
          if [ -n "${FILES_TO_REPLACE}" ]; then
            echo "${FILES_TO_REPLACE}" | xargs -r sed -i -e "s|${OLD_ADMIN_URL}|${NEW_URL_ESCAPED}|g"
            echo -e "\n✅ 已替换文件："
            echo "${FILES_TO_REPLACE}" | awk '{print "  - " $0}'
          else
            echo -e "\nℹ️ 未找到含 ${OLD_ADMIN_URL} 的文件，无需替换"
          fi
          
          # 预览src/common.rs替换结果
          if [ -f "src/common.rs" ]; then
            echo -e "\n==> 替换后：src/common.rs 关键行（前50行）"
            (grep -nE "${OLD_ADMIN_URL//./\\.}|${NEW_ADMIN_URL//./\\.}" src/common.rs || echo "✅ 替换完成") | head -n 50
          fi
          
          # 提交替换变更（仅当有修改时）
          if ! git diff --quiet; then
            git add -A
            git commit -m "chore: replace admin URL to ${NEW_ADMIN_URL}"
            echo -e "\n✅ 已提交admin地址替换变更"
          fi

      # 步骤6：替换目标Dart文件（81-110行，确保格式正确）
      - name: Replace target Dart file (81-110 lines)
        run: |
          set -euo pipefail
          echo "===== 执行步骤6：替换 ${TARGET_DART_FILE} 81-110行 ====="
          REPLACE_START=81
          REPLACE_END=110
          NEW_CODE_END_DEFAULT=89
          
          # 校验Dart文件是否存在
          if [ ! -f "${TARGET_DART_FILE}" ]; then
            echo "::error::${TARGET_DART_FILE} 不存在（注意大小写）"
            exit 1
          fi
          
          # 预览替换前旧代码
          echo "==> 替换前：${TARGET_DART_FILE} ${REPLACE_START}-${REPLACE_END}行"
          if sed -n "${REPLACE_START},${REPLACE_END}p" "${TARGET_DART_FILE}" | grep -q .; then
            sed -n "${REPLACE_START},${REPLACE_END}p" "${TARGET_DART_FILE}"
          else
            echo "ℹ️ 该行数范围无内容，建议确认行数"
          fi
          
          # 生成新代码到临时文件
          printf "%s\n" "Widget setupServerWidget() => Flexible(" \
                         "       child: Offstage(" \
                         "         offstage: !(!_svcStopped.value &&" \
                         "             stateGlobal.svcStatus.value == SvcStatus.ready &&" \
                         "             _svcIsUsingPublicServer.value)," \
                         "         child: Row(" \
                         "           crossAxisAlignment: CrossAxisAlignment.center," \
                         "           children: [],)," \
                         "       )," \
                         "     );" > /tmp/new_dart_code.tmp
          
          # 执行替换并清理临时文件
          sed -i "${REPLACE_START},${REPLACE_END}d" "${TARGET_DART_FILE}"
          sed -i "${REPLACE_START}r /tmp/new_dart_code.tmp" "${TARGET_DART_FILE}"
          rm -f /tmp/new_dart_code.tmp
          echo "✅ 临时文件已清理"
          
          # 预览替换后新代码
          DETECTED_END=$(grep -n ");" "${TARGET_DART_FILE}" | grep -A1 "setupServerWidget" | tail -1 | cut -d: -f1 || echo "${NEW_CODE_END_DEFAULT}")
          FINAL_END=$((DETECTED_END > REPLACE_START ? DETECTED_END : 90))
          echo -e "\n==> 替换后：${TARGET_DART_FILE} ${REPLACE_START}-${FINAL_END}行"
          sed -n "${REPLACE_START},${FINAL_END}p" "${TARGET_DART_FILE}"
          
          # 提交Dart文件变更（仅当有修改时）
          if ! git diff --quiet "${TARGET_DART_FILE}"; then
            git add "${TARGET_DART_FILE}"
            git commit -m "chore: replace ${TARGET_DART_FILE} ${REPLACE_START}-${REPLACE_END} lines"
            echo -e "\n✅ 已提交Dart文件替换变更"
          else
            echo "ℹ️ Dart文件已为目标代码，无需提交"
          fi

      # 步骤7：推送分支+存储远端SHA（精准指定分支，避免与Tag混淆）
      - name: Push branch & save remote SHA
        if: ${{ inputs.push_branch == 'true' }}
        env:
          GH_TOKEN: ${{ secrets.REPO_WORKFLOW_PAT }}
        run: |
          set -euo pipefail
          echo "===== 执行步骤7：推送分支并存储远端SHA ====="
          # 配置带权限的远端地址
          git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
          
          # 精准指定分支推送路径，避免与Tag冲突
          if [ "${{ inputs.force }}" = "true" ]; then
            git push --force-with-lease origin "refs/heads/${WORK_BRANCH}:refs/heads/${WORK_BRANCH}"
            echo "✅ 已强制推送分支 ${WORK_BRANCH} 到远端"
          else
            git push origin "refs/heads/${WORK_BRANCH}:refs/heads/${WORK_BRANCH}"
            echo "✅ 已正常推送分支 ${WORK_BRANCH} 到远端"
          fi
          
          # 存储远端分支SHA，为Tag校验做准备
          REMOTE_BRANCH_SHA=$(git ls-remote origin "refs/heads/${WORK_BRANCH}" | awk '{print $1}')
          echo "REMOTE_BRANCH_SHA=${REMOTE_BRANCH_SHA}" >> "$GITHUB_ENV"
          echo "✅ 已存储远端分支SHA：${REMOTE_BRANCH_SHA}"

      # 步骤8：创建&校验Tag（同步最新SHA，确保与分支一致）
      - name: Create & verify Tag
        if: ${{ inputs.do_tag == 'true' }}
        env:
          GH_TOKEN: ${{ secrets.REPO_WORKFLOW_PAT }}
        run: |
          set -euo pipefail
          echo "===== 执行步骤8：创建并校验Tag ====="
          # 定义变量（兜底空值，同步最新本地SHA）
          TAG="${{ inputs.version }}"
          [ -z "${TAG}" ] && TAG="${WORK_BRANCH}"
          TAG_MSG="${{ inputs.tag_message }}"
          # 拉取远端最新分支，确保本地SHA与远端一致
          git pull origin "${WORK_BRANCH}" --ff-only
          LOCAL_BRANCH_SHA=$(git rev-parse "${WORK_BRANCH}^{commit}")
          
          # 补全远端SHA（双重兜底）
          REMOTE_BRANCH_SHA="${{ env.REMOTE_BRANCH_SHA }}"
          if [ -z "${REMOTE_BRANCH_SHA}" ]; then
            REMOTE_BRANCH_SHA=$(git ls-remote origin "refs/heads/${WORK_BRANCH}" | awk '{print $1}')
            [ -z "${REMOTE_BRANCH_SHA}" ] && { echo "::error::无法获取远端分支SHA"; exit 1; }
          fi
          
          # 打印核心配置（确认本地与远端SHA一致）
          echo "✅ 核心配置："
          echo "  - Tag名称：${TAG}"
          echo "  - Tag注释：${TAG_MSG}"
          echo "  - 本地分支SHA：${LOCAL_BRANCH_SHA}"
          echo "  - 远端分支SHA：${REMOTE_BRANCH_SHA}"
          
          # 处理旧Tag（按配置删除）
          git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
          if [ "${{ inputs.retag }}" = "true" ]; then
            git push origin ":refs/tags/${TAG}" || echo "ℹ️ 远端无旧Tag ${TAG}，无需删除"
            git tag -d "${TAG}" 2>/dev/null || true
          fi
          
          # 创建并推送新Tag
          git tag -a "${TAG}" -m "${TAG_MSG}" "${LOCAL_BRANCH_SHA}"
          git push origin "refs/tags/${TAG}"
          echo "✅ 已创建并推送Tag：${TAG}（指向SHA：${LOCAL_BRANCH_SHA}）"
          
          # 校验Tag与分支SHA一致性
          REMOTE_TAG_SHA=$(git ls-remote --tags origin "refs/tags/${TAG}^{}" | awk '{print $1}')
          [ -z "${REMOTE_TAG_SHA}" ] && REMOTE_TAG_SHA=$(git ls-remote --tags origin "refs/tags/${TAG}" | awk '{print $1}')

          # 最终SHA一致性校验
          if [ "${REMOTE_TAG_SHA}" != "${REMOTE_BRANCH_SHA}" ]; then
            echo "::error::Tag校验失败：Tag SHA(${REMOTE_TAG_SHA}) ≠ 远端分支SHA(${REMOTE_BRANCH_SHA})"
            exit 1
          fi
          echo "✅ Tag校验通过：${TAG} 与远端分支 ${WORK_BRANCH} SHA完全一致"

      # 步骤9：最终全流程校验（确认所有操作结果）
      - name: Final full verification
        run: |
          set -euo pipefail
          echo -e "\n===== 执行步骤9：最终全流程校验 ====="
          
          # 1. 分支状态校验
          echo -e "\n1. 分支状态"
          git status --short
          git show -s --format="  分支：${WORK_BRANCH}\n  最新提交SHA：%H\n  提交时间：%ad\n  提交说明：%s" "${WORK_BRANCH}"
          
          # 2. Dart文件替换结果校验（核心特征匹配）
          echo -e "\n2. Dart文件替换校验"
          if grep -q "Widget setupServerWidget() => Flexible(" "${TARGET_DART_FILE}" && grep -q "children: \[\]," "${TARGET_DART_FILE}"; then
            echo "  ✅ 替换成功：已检测到新代码核心特征"
          else
            echo "  ❗ 警告：未检测到新代码特征，建议核查 ${TARGET_DART_FILE}"
          fi
          
          # 3. admin地址替换校验（针对src/common.rs）
          echo -e "\n3. admin地址替换校验"
          if [ -f "src/common.rs" ]; then
            if grep -q "${{ inputs.admin_url }}" "src/common.rs"; then
              echo "  ✅ 替换成功：src/common.rs 已包含新admin地址"
            elif grep -q "https://admin.rustdesk.com" "src/common.rs"; then
              echo "  ❗ 警告：src/common.rs 仍存在旧admin地址"
            else
              echo "  ℹ️ 信息：src/common.rs 无旧/新admin地址"
            fi
          else
            echo "  ℹ️ 信息：未找到 src/common.rs 文件，跳过地址校验"
          fi
          
          # 4. 子模块状态校验
          echo -e "\n4. 子模块状态校验"
          SM_PATH="libs/hbb_common"
          SM_BRANCH=$(git -C "${SM_PATH}" rev-parse --abbrev-ref HEAD)
          SM_SHA=$(git -C "${SM_PATH}" rev-parse HEAD)
          echo "  - 子模块分支：${SM_BRANCH}"
          echo "  - 子模块当前SHA：${SM_SHA}"
          echo "  - 子模块远端最新SHA：$(git ls-remote "${{ inputs.submodule_url }}" "refs/heads/${SM_BRANCH}" | awk '{print $1}')"
          
          # 5. Tag信息校验（仅开启打Tag时）
          if [ "${{ inputs.do_tag == 'true' }}" = "true" ]; then
            echo -e "\n5. Tag信息校验"
            TAG="${{ inputs.version || env.WORK_BRANCH }}"
            git tag -l "${TAG}" --format="  存在状态：%1.1s\n  Tag注释：%(contents)\n  Tag指向SHA：%(objectname)\n  创建时间：%(taggerdate)"
          fi
          
          echo -e "\n===== 全流程执行完成，所有核心操作校验通过 ====="
          
