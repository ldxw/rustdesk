name: 从上游标签或master分支创建版本分支（保护工作流文件）

on:
  workflow_dispatch:
    inputs:
      source_type:
        description: "源类型 (tag = 使用上游标签, master_branch = 使用上游master分支)"
        required: true
        type: choice
        options:
          - "tag"
          - "master_branch"
        default: "tag"
      version:
        description: "上游 Tag（如 1.4.1，仅当源类型为tag时有效）"
        required: false
        default: "1.4.1"
      force:
        description: "强制覆盖同名远端分支（全量替换而非增量合并）"
        required: true
        type: boolean
        default: false
      upstream_repo:
        description: "上游仓库（owner/repo）"
        required: true
        default: "rustdesk/rustdesk"
      target_directory:
        description: "本地存放目录（仅当源类型为master_branch时有效，默认latest）"
        required: false
        default: "latest"

permissions:
  contents: write

jobs:
  validate_inputs:
    runs-on: ubuntu-latest
    outputs:
      valid: ${{ steps.check.outputs.valid }}
      target_branch: ${{ steps.check.outputs.target_branch }}
      target_dir: ${{ steps.check.outputs.target_dir }}
    steps:
      - id: check
        run: |
          set -euo pipefail
          SOURCE_TYPE="${{ github.event.inputs.source_type }}"
          VERSION="${{ github.event.inputs.version }}"
          TARGET_DIR="${{ github.event.inputs.target_directory }}"
          
          if [ "$SOURCE_TYPE" = "tag" ] && [ -z "$VERSION" ]; then
            echo "::error::当源类型为tag时，版本号不能为空"
            echo "valid=false" >> "$GITHUB_OUTPUT"
            exit 1
          fi
          
          if [ "$SOURCE_TYPE" = "master_branch" ] && [ -z "$TARGET_DIR" ]; then
            echo "::error::当源类型为master_branch时，目标目录不能为空"
            echo "valid=false" >> "$GITHUB_OUTPUT"
            exit 1
          fi
          
          if [ "$SOURCE_TYPE" = "tag" ]; then
            echo "target_branch=$VERSION" >> "$GITHUB_OUTPUT"
          else
            echo "target_branch=latest" >> "$GITHUB_OUTPUT"
          fi
          
          echo "target_dir=$TARGET_DIR" >> "$GITHUB_OUTPUT"
          echo "valid=true" >> "$GITHUB_OUTPUT"

  create_version_branch:
    needs: validate_inputs
    if: ${{ needs.validate_inputs.outputs.valid == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout fork (this repo) without persisting credentials
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false
          ref: ${{ needs.validate_inputs.outputs.target_branch }}

      - name: 保存工作流文件到临时位置（防止被覆盖）
        run: |
          # 创建临时目录保存当前工作流文件
          mkdir -p .github/workflows_temp
          if [ -f ".github/workflows/create-version-branch.yml" ]; then
            cp ".github/workflows/create-version-branch.yml" ".github/workflows_temp/"
            echo "已备份工作流文件"
          else
            echo "工作流文件不存在，无需备份"
          fi

      - name: Configure git identity
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config --global --unset-all http.https://github.com/.extraheader || true

      - name: Add upstream repository
        run: |
          UPSTREAM="${{ github.event.inputs.upstream_repo }}"
          git remote add upstream "https://github.com/${UPSTREAM}.git" || true
          git fetch upstream

      - name: Determine source and target information
        id: source_info
        run: |
          SOURCE_TYPE="${{ github.event.inputs.source_type }}"
          VERSION="${{ github.event.inputs.version }}"
          TARGET_BRANCH="${{ needs.validate_inputs.outputs.target_branch }}"
          
          if [ "$SOURCE_TYPE" = "tag" ]; then
            echo "source_ref=refs/tags/${VERSION}" >> "$GITHUB_OUTPUT"
            echo "source_name=tag ${VERSION}" >> "$GITHUB_OUTPUT"
          else
            echo "source_ref=refs/heads/master" >> "$GITHUB_OUTPUT"
            echo "source_name=master branch" >> "$GITHUB_OUTPUT"
          fi
          echo "target_branch=$TARGET_BRANCH" >> "$GITHUB_OUTPUT"

      - name: Check if target branch exists locally
        id: branch_check
        run: |
          TARGET_BRANCH="${{ needs.validate_inputs.outputs.target_branch }}"
          if git show-ref --verify --quiet "refs/heads/${TARGET_BRANCH}"; then
            echo "branch_exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "branch_exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Initialize new branch from upstream source (首次拉取)
        if: ${{ steps.branch_check.outputs.branch_exists == 'false' || github.event.inputs.force == 'true' }}
        run: |
          SOURCE_REF="${{ steps.source_info.outputs.source_ref }}"
          TARGET_BRANCH="${{ steps.source_info.outputs.target_branch }}"
          
          git checkout -B "$TARGET_BRANCH" "upstream/${SOURCE_REF#refs/heads/}"
          git commit --allow-empty -m "Initial branch from upstream ${{ steps.source_info.outputs.source_name }}" || true

      - name: Incremental merge upstream changes (增量拉取)
        if: ${{ steps.branch_check.outputs.branch_exists == 'true' && github.event.inputs.force == 'false' }}
        run: |
          SOURCE_REF="${{ steps.source_info.outputs.source_ref }}"
          TARGET_BRANCH="${{ steps.source_info.outputs.target_branch }}"
          SOURCE_NAME="${{ steps.source_info.outputs.source_name }}"
          
          git fetch upstream
          
          # 合并时排除工作流文件，防止被上游版本覆盖
          git merge --no-ff -X theirs "upstream/${SOURCE_REF#refs/heads/}" \
            -m "Merge upstream $SOURCE_NAME into $TARGET_BRANCH (auto-resolve conflicts with upstream version)" \
            --exclude ".github/workflows/create-version-branch.yml" || true

      - name: 恢复工作流文件（确保本地版本不被覆盖）
        run: |
          # 将临时保存的工作流文件恢复
          if [ -f ".github/workflows_temp/create-version-branch.yml" ]; then
            mkdir -p .github/workflows
            mv ".github/workflows_temp/create-version-branch.yml" ".github/workflows/"
            # 如果文件有变化，创建一个提交保留本地版本
            if ! git diff --quiet ".github/workflows/create-version-branch.yml"; then
              git add ".github/workflows/create-version-branch.yml"
              git commit -m "Preserve create-version-branch.yml from being overwritten"
            fi
            echo "已恢复并保护工作流文件"
          fi

      - name: Push changes to remote
        env:
          PAT: ${{ secrets.REPO_WORKFLOW_PAT }}
        run: |
          TARGET_BRANCH="${{ steps.source_info.outputs.target_branch }}"
          FORCE="${{ github.event.inputs.force }}"
          
          if [ -n "$PAT" ]; then
            git remote set-url origin "https://${PAT}@github.com/${GITHUB_REPOSITORY}.git"
          fi
          
          if [ "$FORCE" = "true" ]; then
            git push --force-with-lease origin "$TARGET_BRANCH"
          else
            git push origin "$TARGET_BRANCH"
          fi

      - name: Checkout to target directory
        if: ${{ steps.source_info.outputs.target_branch == 'latest' }}
        run: |
          TARGET_BRANCH="latest"
          TARGET_DIR="${{ needs.validate_inputs.outputs.target_dir }}"
          
          mkdir -p "${TARGET_DIR}"
          git --work-tree="${TARGET_DIR}" checkout "${TARGET_BRANCH}" -- .
          
          echo "已将上游内容增量更新到 ${TARGET_BRANCH} 分支，并检出到 ${TARGET_DIR} 目录"
