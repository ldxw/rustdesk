name: 仅打Tag编译：替换URL后在分支HEAD打标签（不推分支）

on:
  workflow_dispatch:
    inputs:
      work_branch:
        description: "要打Tag的分支（例如 1.4.2）"
        required: true
        default: "1.4.2"
      admin_url:
        description: "把 src/common.rs 中的 https://admin.rustdesk.com 替换为该地址"
        required: true
        default: "https://admin-hy.rs.ldxw.top"
      version:
        description: "Tag 名（留空则使用 work_branch）"
        required: false
        default: ""
      tag_message:
        description: "Tag 注释信息"
        required: false
        default: "修改内置服务器和 key"
      retag:
        description: "是否强制重打Tag（先删远端同名Tag再重建，推荐 true 用于触发构建）"
        type: choice
        options: ["true", "false"]
        required: true
        default: "true"
      force:
        description: "本地创建Tag是否 -f 覆盖（通常不需要）"
        type: choice
        options: ["false", "true"]
        required: true
        default: "false"

permissions:
  contents: write

jobs:
  tag_only:
    runs-on: ubuntu-latest
    env:
      WORK_BRANCH: ${{ inputs.work_branch }}
    steps:
      - name: Checkout repo (no creds persisted)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Git identity
        run: |
          set -euo pipefail
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Prepare branch (local-only, we will NOT push branch)
        run: |
          set -euo pipefail
          git fetch origin --no-tags
          if git show-ref --verify --quiet "refs/remotes/origin/${WORK_BRANCH}"; then
            # 确保本地有该分支并与远端同步
            if git show-ref --verify --quiet "refs/heads/${WORK_BRANCH}"; then
              git checkout "${WORK_BRANCH}"
              git merge --ff-only "origin/${WORK_BRANCH}" || true
            else
              git checkout -B "${WORK_BRANCH}" "origin/${WORK_BRANCH}"
            fi
          else
            echo "::error::远端不存在分支 origin/${WORK_BRANCH}"
            exit 1
          fi

      - name: Replace admin URL in src/common.rs (HTTPS only)
        run: |
          set -euo pipefail
          FILE="src/common.rs"
          NEW_URL='${{ inputs.admin_url }}'

          if [ ! -f "$FILE" ]; then
            echo "::error file=${FILE}::未找到 ${FILE}，无法替换"
            exit 1
          fi

          echo "==> 替换前匹配（最多显示 50 行）"
          (grep -n "https://admin\.rustdesk\.com" "$FILE" || true) | head -n 50

          before_sha=$(sha256sum "$FILE" | awk '{print $1}')
          new_esc=${NEW_URL//&/\\&}
          sed -i -e "s|https://admin\.rustdesk\.com|${new_esc}|g" "$FILE"
          after_sha=$(sha256sum "$FILE" | awk '{print $1}')

          echo "==> 替换后匹配（最多显示 50 行）"
          (grep -nE 'admin\.rustdesk\.com|rs\.ldxw\.top|admin-hy' "$FILE" || true) | head -n 50

          if [ "$before_sha" != "$after_sha" ]; then
            git add "$FILE"
            git commit -m "chore: replace https://admin.rustdesk.com -> ${NEW_URL}"
            echo "changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "内容无变化（可能已是目标URL），继续打Tag。"
            echo "changed=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Create tag at branch HEAD (anchored)
        id: tag_step
        env:
          GH_TOKEN: ${{ secrets.REPO_WORKFLOW_PAT }}   # 需要 repo 权限
        run: |
          set -euo pipefail
          # 计算 Tag 名
          TAG_IN='${{ inputs.version }}'
          TAG="$TAG_IN"
          if [ -z "$TAG" ]; then TAG="${WORK_BRANCH}"; fi
          MSG='${{ inputs.tag_message }}'
          FORCE='${{ inputs.force }}'
          RETAG='${{ inputs.retag }}'

          # 取分支当前提交（包含上一步本地提交）
          BRANCH_SHA="$(git rev-parse "${WORK_BRANCH}^{commit}")"
          echo "Branch(${WORK_BRANCH}) HEAD: ${BRANCH_SHA}"

          # （按需）删除远端同名Tag，确保触发并防止旧引用
          if [ "$RETAG" = "true" ]; then
            git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
            git push origin ":refs/tags/${TAG}" || true
          fi

          # 删除本地旧Tag
          git tag -d "${TAG}" 2>/dev/null || true
          # 创建注释Tag并显式锚定到分支HEAD
          if [ "$FORCE" = "true" ]; then
            git tag -a -f "${TAG}" -m "${MSG}" "${BRANCH_SHA}"
          else
            git tag -a "${TAG}" -m "${MSG}" "${BRANCH_SHA}"
          fi

          # 仅推送Tag（不推分支）
          git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
          git push origin "refs/tags/${TAG}"

          # 校验远端Tag是否等于本地分支HEAD
          REMOTE_TAG_SHA="$(git ls-remote --tags origin "refs/tags/${TAG}" | awk '{print $1}')"
          echo "Remote Tag(${TAG}) -> ${REMOTE_TAG_SHA}"
          if [ -z "${REMOTE_TAG_SHA}" ] || [ "${REMOTE_TAG_SHA}" != "${BRANCH_SHA}" ]; then
            echo "::error::远端Tag ${TAG} 未指向分支 ${WORK_BRANCH} 的HEAD（期望 ${BRANCH_SHA}，实得 ${REMOTE_TAG_SHA:-<none>}）"
            exit 1
          fi
          echo "tag_name=${TAG}" >> "$GITHUB_OUTPUT"

      - name: Show final refs and src/common.rs snippet
        run: |
          set -euo pipefail
          TAG='${{ steps.tag_step.outputs.tag_name }}'
          echo "---- Branch ${WORK_BRANCH} (local) ----"
          git show -s --format="Commit %H%nDate   %ad%n%n%s" "${WORK_BRANCH}"
          echo "---- Tag ${TAG} ----"
          git show -s --format="Commit %H%nDate   %ad%n%n%s" "refs/tags/${TAG}"
          echo "---- src/common.rs 片段（替换后的关键行） ----"
          (grep -nE 'admin\.rustdesk\.com|rs\.ldxw\.top|admin-hy' src/common.rs || true) | head -n 80
