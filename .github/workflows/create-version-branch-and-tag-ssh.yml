name: 直接在分支修改：公开子模块+仅HTTPS替换+打Tag（可控推送/重打Tag）

on:
  workflow_dispatch:
    inputs:
      work_branch:
        description: "要修改并推送的分支（变量，例如 1.4.2）"
        required: true
        default: "1.4.2"
      force:
        description: "是否强推分支/覆盖同名Tag"
        type: choice
        options: ["false", "true"]
        required: true
        default: "false"

      # 子模块（公开仓库，HTTPS）——如不需要改动也没关系（无更改不会提交）
      submodule_url:
        description: "子模块公开仓库（HTTPS）地址"
        required: true
        default: "https://github.com/ldxw/rustdesk_hbb_common.git"
      submodule_branch:
        description: "子模块分支（auto=自动检测远端默认分支）"
        required: true
        default: "auto"

      # 仅替换 https://admin.rustdesk.com
      admin_url:
        description: "将仓库内所有 https://admin.rustdesk.com 替换为该地址"
        required: true
        default: "https://admin-hy.rs.ldxw.top"

      # 推送与打Tag选项（≤10 inputs）
      push_branch:
        description: "是否推送分支（true=推送；false=只本地提交，不推分支）"
        type: choice
        options: ["true", "false"]
        required: true
        default: "true"
      do_tag:
        description: "是否在 work_branch 的 HEAD 打 Tag（版本号见下方）"
        type: choice
        options: ["false", "true"]
        required: true
        default: "true"
      version:
        description: "Tag 名（留空则使用 work_branch 的值，例如 1.4.2）"
        required: false
        default: ""
      tag_message:
        description: "Tag 注释信息"
        required: false
        default: "修改内置服务器和 key"
      retag:
        description: "是否无条件重打Tag（true=先删远端同名Tag再重建；适合强制触发构建）"
        type: choice
        options: ["false", "true"]
        required: true
        default: "true"

permissions:
  contents: write

jobs:
  run:
    runs-on: ubuntu-latest
    env:
      WORK_BRANCH: ${{ inputs.work_branch }}
      FORCE: ${{ inputs.force }}
    steps:
      - name: Checkout this repo (no submodules)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Git identity
        run: |
          set -euo pipefail
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      # 切到目标分支
      - name: Ensure local branch from origin
        run: |
          set -euo pipefail
          git fetch origin --no-tags
          if git show-ref --verify --quiet "refs/heads/${WORK_BRANCH}"; then
            git checkout "${WORK_BRANCH}"
            if git show-ref --verify --quiet "refs/remotes/origin/${WORK_BRANCH}"; then
              git merge --ff-only "origin/${WORK_BRANCH}" || true
            fi
          else
            if git show-ref --verify --quiet "refs/remotes/origin/${WORK_BRANCH}"; then
              git checkout -B "${WORK_BRANCH}" "origin/${WORK_BRANCH}"
            else
              echo "::error::远端不存在分支 origin/${WORK_BRANCH}，请先创建后再运行。"
              exit 1
            fi
          fi

      # 子模块：检测默认分支并写入 .gitmodules（如无变更不会提交）
      - name: Prepare submodule config (auto-detect branch if needed)
        id: sm_prep
        run: |
          set -euo pipefail
          SM_NAME='libs/hbb_common'
          SM_PATH='libs/hbb_common'
          SM_URL='${{ inputs.submodule_url }}'
          REQ_BRANCH='${{ inputs.submodule_branch }}'

          DETECTED_BRANCH="$REQ_BRANCH"
          if [ "$REQ_BRANCH" = "auto" ] || ! git ls-remote --heads "${SM_URL}" "${REQ_BRANCH}" | grep -q .; then
            DETECTED_BRANCH="$(git ls-remote --symref "${SM_URL}" HEAD | awk '/^ref:/ {print $2}' | sed 's#refs/heads/##')"
            if [ -z "${DETECTED_BRANCH}" ]; then
              echo "::error::无法检测子模块远端默认分支，请手动指定 submodule_branch。"
              exit 1
            fi
          fi
          echo "sm_branch=${DETECTED_BRANCH}" >> "$GITHUB_OUTPUT"

          git config -f .gitmodules "submodule.${SM_NAME}.url"    "${SM_URL}"
          git config -f .gitmodules "submodule.${SM_NAME}.path"   "${SM_PATH}"
          git config -f .gitmodules "submodule.${SM_NAME}.branch" "${DETECTED_BRANCH}"
          git add .gitmodules
          if ! git diff --cached --quiet; then
            git commit -m "使用公开子模块 ${SM_URL}，分支 ${DETECTED_BRANCH}"
          fi

          git submodule set-url    "${SM_PATH}" "${SM_URL}" || true
          git submodule set-branch --branch "${DETECTED_BRANCH}" "${SM_PATH}" || true

      - name: Sync & update submodule (remote)
        run: |
          set -euo pipefail
          SM_PATH='libs/hbb_common'
          SM_BRANCH='${{ steps.sm_prep.outputs.sm_branch }}'
          if [ -d "${SM_PATH}" ] && [ ! -d "${SM_PATH}/.git" ] && [ ! -f "${SM_PATH}/.git" ]; then
            rm -rf "${SM_PATH}"
          fi
          git submodule sync -- "${SM_PATH}"
          git submodule update --init --remote "${SM_PATH}"
          git -C "${SM_PATH}" fetch origin --no-tags || true
          if git -C "${SM_PATH}" rev-parse --verify -q "refs/remotes/origin/${SM_BRANCH}" >/dev/null; then
            git -C "${SM_PATH}" checkout -B "${SM_BRANCH}" "origin/${SM_BRANCH}"
          fi
          git add "${SM_PATH}"
          if ! git diff --cached --quiet; then
            git commit -m "更新子模块 ${SM_PATH} 至远端分支 ${SM_BRANCH} 的最新提交"
          fi

      # 仅替换 https://admin.rustdesk.com（排除子模块目录）
      - name: Replace admin HTTPS URLs (exclude submodule)
        run: |
          set -euo pipefail
          NEW_URL='${{ inputs.admin_url }}'

          echo "==> 替换前命中（前 100 行）"
          (git grep -n -E 'https://admin\.rustdesk\.com' -- ':!:libs/hbb_common' || true) | head -n 100

          files_http=$(git grep -l -E 'https://admin\.rustdesk\.com' -- ':!:libs/hbb_common' || true)
          if [ -n "${files_http}" ]; then
            new_esc=${NEW_URL//&/\\&}
            echo "${files_http}" | xargs -r sed -i -e "s|https://admin\.rustdesk\.com|${new_esc}|g"
          fi

          # 重点校验 src/common.rs 是否命中/变更
          if [ -f "src/common.rs" ]; then
            echo "==> src/common.rs 替换后预览（匹配行）"
            (grep -nE 'admin\.rustdesk\.com|admin-hy|rs\.ldxw\.top' src/common.rs || true) | head -n 50
          fi

          if ! git diff --quiet; then
            git add -A
            git commit -m "chore: replace https://admin.rustdesk.com -> ${NEW_URL}"
          else
            echo "没有发现需要替换或内容已是最新。"
          fi

          echo "==> 替换后残留（前 100 行）"
          (git grep -n -E 'https://admin\.rustdesk\.com' -- ':!:libs/hbb_common' || true) | head -n 100

      # 可选：推分支（由 push_branch 控制）
      - name: Push branch via PAT (optional)
        if: ${{ inputs.push_branch == 'true' }}
        env:
          GH_TOKEN: ${{ secrets.REPO_WORKFLOW_PAT }}
        run: |
          set -euo pipefail
          git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
          if [ "$FORCE" = "true" ]; then
            git push --force-with-lease origin "HEAD:refs/heads/${WORK_BRANCH}"
          else
            git push origin "HEAD:refs/heads/${WORK_BRANCH}"
          fi

      # 打 Tag：确保 Tag 指向分支 HEAD；若 retag=true 或 mismatch/force，则删除远端Tag后重建并校验
      - name: Create/Retarget tag to branch HEAD (with verification)
        if: ${{ inputs.do_tag == 'true' }}
        env:
          GH_TOKEN: ${{ secrets.REPO_WORKFLOW_PAT }}
        run: |
          set -euo pipefail
          TAG_INPUT='${{ inputs.version }}'
          TAG="$TAG_INPUT"
          if [ -z "$TAG" ]; then TAG="${WORK_BRANCH}"; fi
          MSG='${{ inputs.tag_message }}'

          BRANCH_SHA="$(git rev-parse "${WORK_BRANCH}^{commit}")"
          REMOTE_TAG_SHA="$(git ls-remote --tags origin "refs/tags/${TAG}" | awk '{print $1}' || true)"

          echo "Branch(${WORK_BRANCH}) SHA: ${BRANCH_SHA}"
          echo "Remote Tag(${TAG}) SHA:  ${REMOTE_TAG_SHA:-<none>}"

          # 条件：retag=true 或 tag 不存在 或 tag 指向旧提交 或 force=true -> 重打
          if [ "${{ inputs.retag }}" = "true" ] || [ -z "${REMOTE_TAG_SHA}" ] || [ "${REMOTE_TAG_SHA}" != "${BRANCH_SHA}" ] || [ "$FORCE" = "true" ]; then
            git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
            git push origin ":refs/tags/${TAG}" || true
            git tag -d "${TAG}" 2>/dev/null || true
            git tag -a "${TAG}" -m "${MSG}" "${BRANCH_SHA}"
            git push origin "refs/tags/${TAG}"
          else
            echo "远端Tag ${TAG} 已指向分支HEAD，无需变更。"
          fi

          NEW_REMOTE_TAG_SHA="$(git ls-remote --tags origin "refs/tags/${TAG}" | awk '{print $1}')"
          echo "Verified Remote Tag(${TAG}) SHA: ${NEW_REMOTE_TAG_SHA}"
          if [ -z "${NEW_REMOTE_TAG_SHA}" ] || [ "${NEW_REMOTE_TAG_SHA}" != "${BRANCH_SHA}" ]; then
            echo "::error::校验失败：远端Tag ${TAG} 未指向分支 ${WORK_BRANCH} 的HEAD（期望 ${BRANCH_SHA}，实得 ${NEW_REMOTE_TAG_SHA:-<none>}）"
            exit 1
          fi

      # 显示最终引用与 src/common.rs 片段，便于在日志里核对
      - name: Show final refs and src/common.rs snippet
        run: |
          set -euo pipefail
          echo "---- Branch ${WORK_BRANCH} ----"
          git show -s --format="Commit %H%nAuthor  %an%nDate    %ad%n%n%s" "${WORK_BRANCH}"
          if [ -f "src/common.rs" ]; then
            echo "---- src/common.rs 中含 admin/ldxw 的行 ----"
            (grep -nE 'admin\.rustdesk\.com|admin-hy|rs\.ldxw\.top' src/common.rs || true) | head -n 80
          fi
          if [ "${{ inputs.do_tag }}" = "true" ]; then
            TAG_IN='${{ inputs.version }}'; TAG="$TAG_IN"; if [ -z "$TAG" ]; then TAG="${WORK_BRANCH}"; fi
            echo "---- Tag ${TAG} ----"
            git show -s --format="Commit %H%nAuthor %an%nDate   %ad%n%n%s" "refs/tags/${TAG}"
          fi
