name: 更新分支并打Tag：子模块 + URL替换 + Tag锚定分支HEAD

run-name: >-
  更新 ${{ inputs.work_branch }}
  ${{ inputs.do_tag == 'true' && format('+ 打Tag {0}', (inputs.version != '' && inputs.version || inputs.work_branch)) || '' }}

on:
  workflow_dispatch:
    inputs:
      work_branch:
        description: "要更新并打Tag的分支（例如 1.4.2）"
        required: true
        default: "1.4.2"

      # 可选覆盖：留空则使用 Secrets.ADMIN_URL
      admin_url:
        description: "可选覆盖：将仓库内所有 https://admin-hy.rs.ldxw.top 替换为该地址（留空=Secrets.ADMIN_URL；不改子模块）"
        required: false
        default: ""

      # 可选覆盖：留空则使用 Secrets.DOWNLOAD_URL
      download_url:
        description: "可选覆盖：将仓库内所有 https://rustdesk.com/download 替换为该地址（留空=Secrets.DOWNLOAD_URL；排除子模块）"
        required: false
        default: ""

      # 可选覆盖：留空则使用 Secrets.HBB_COMMON_URL
      submodule_url:
        description: "可选覆盖：libs/hbb_common 子模块公开仓库（HTTPS）（留空=Secrets.HBB_COMMON_URL）"
        required: false
        default: ""

      submodule_branch:
        description: "libs/hbb_common 子模块分支（auto=自动检测远端默认分支）"
        required: true
        default: "auto"

      push_branch:
        description: "是否推送分支（true=推；false=只本地更改但仍可推Tag）"
        type: choice
        options: ["true", "false"]
        required: true
        default: "true"

      force:
        description: "推分支/建Tag是否强制（分支用 --force-with-lease；Tag 用 -f）"
        type: choice
        options: ["false", "true"]
        required: true
        default: "false"

      do_tag:
        description: "是否在分支HEAD打Tag"
        type: choice
        options: ["true", "false"]
        required: true
        default: "true"

      version:
        description: "Tag 名（留空使用 work_branch）"
        required: false
        default: ""

      tag_message:
        description: "Tag 注释"
        required: false
        default: "修改内置服务器和 key"

      retag:
        description: "是否强制重打Tag（先删远端同名Tag再建）"
        type: choice
        options: ["true", "false"]
        required: true
        default: "true"

permissions:
  contents: write

jobs:
  update_and_tag:
    runs-on: ubuntu-latest
    env:
      WORK_BRANCH: ${{ inputs.work_branch }}

      # —— 输入优先，留空走 secrets —— #
      ADMIN_URL: ${{ inputs.admin_url != '' && inputs.admin_url || secrets.ADMIN_URL }}
      DOWNLOAD_URL: ${{ inputs.download_url != '' && inputs.download_url || secrets.DOWNLOAD_URL }}
      SUBMODULE_URL: ${{ inputs.submodule_url != '' && inputs.submodule_url || secrets.HBB_COMMON_URL }}

    steps:
      - name: Checkout repo (no submodules, no persisted creds)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Validate required secrets/inputs
        run: |
          set -euo pipefail
          missing=0

          if [ -z "${ADMIN_URL}" ]; then
            echo "::error::ADMIN_URL 为空：请在 inputs.admin_url 填值或设置 Secrets.ADMIN_URL"
            missing=1
          fi
          if [ -z "${DOWNLOAD_URL}" ]; then
            echo "::error::DOWNLOAD_URL 为空：请在 inputs.download_url 填值或设置 Secrets.DOWNLOAD_URL"
            missing=1
          fi
          if [ -z "${SUBMODULE_URL}" ]; then
            echo "::error::SUBMODULE_URL 为空：请在 inputs.submodule_url 填值或设置 Secrets.HBB_COMMON_URL"
            missing=1
          fi

          # PAT_TOKEN 必须存在
          if [ -z "${{ secrets.PAT_TOKEN }}" ]; then
            echo "::error::Secrets.PAT_TOKEN 未设置：请放入 Fine-grained PAT（Contents RW + Workflows RW）"
            missing=1
          fi

          exit $missing

      - name: Git identity
        run: |
          set -euo pipefail
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Prepare branch locally
        run: |
          set -euo pipefail
          git fetch origin --no-tags

          if git show-ref --verify --quiet "refs/remotes/origin/${WORK_BRANCH}"; then
            if git show-ref --verify --quiet "refs/heads/${WORK_BRANCH}"; then
              git checkout "${WORK_BRANCH}"
              git merge --ff-only "refs/remotes/origin/${WORK_BRANCH}" || true
            else
              git checkout -B "${WORK_BRANCH}" "refs/remotes/origin/${WORK_BRANCH}"
            fi
          else
            echo "::error::远端不存在分支 origin/${WORK_BRANCH}"
            exit 1
          fi

      # —— 统一设置认证远端（Fine-grained PAT）—— #
      - name: Set authenticated origin (PAT_TOKEN)
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          set -euo pipefail
          git remote set-url origin "https://x-access-token:${PAT_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
          # 验证能读到远端（避免后面才报 403）
          git ls-remote origin -h "refs/heads/${WORK_BRANCH}" >/dev/null

      # 子模块：指向公开库 + 指定/自动分支，并更新指针
      - name: Configure submodule and update pointer
        id: sm_update
        run: |
          set -euo pipefail
          SM_NAME='libs/hbb_common'
          SM_PATH='libs/hbb_common'
          SM_URL="${SUBMODULE_URL}"
          REQ_BRANCH='${{ inputs.submodule_branch }}'

          if [ ! -f .gitmodules ]; then
            echo "::error::.gitmodules 不存在，项目未声明子模块。"
            exit 1
          fi

          DETECTED_BRANCH="$REQ_BRANCH"
          if [ "$REQ_BRANCH" = "auto" ] || ! git ls-remote --heads "${SM_URL}" "${REQ_BRANCH}" | grep -q .; then
            DETECTED_BRANCH="$(git ls-remote --symref "${SM_URL}" HEAD | awk '/^ref:/ {print $2}' | sed 's#refs/heads/##')"
            if [ -z "${DETECTED_BRANCH}" ]; then
              echo "::error::无法检测子模块远端默认分支，请手动指定 submodule_branch"
              exit 1
            fi
            echo "Auto-detected submodule default branch: ${DETECTED_BRANCH}"
          fi
          echo "sm_branch=${DETECTED_BRANCH}" >> "$GITHUB_OUTPUT"

          # 更新 .gitmodules（url/path/branch）
          git config -f .gitmodules "submodule.${SM_NAME}.url"    "${SM_URL}"
          git config -f .gitmodules "submodule.${SM_NAME}.path"   "${SM_PATH}"
          git config -f .gitmodules "submodule.${SM_NAME}.branch" "${DETECTED_BRANCH}"
          git add .gitmodules
          if ! git diff --cached --quiet; then
            git commit -m "chore: use public submodule (${DETECTED_BRANCH})"
          fi

          # 同步并更新子模块到远端最新
          git submodule sync -- "${SM_PATH}"
          git submodule set-url "${SM_PATH}" "${SM_URL}" || true
          git submodule set-branch --branch "${DETECTED_BRANCH}" "${SM_PATH}" || true
          git submodule update --init --remote "${SM_PATH}"

          git -C "${SM_PATH}" fetch origin --no-tags
          if ! git -C "${SM_PATH}" rev-parse --verify -q "refs/remotes/origin/${DETECTED_BRANCH}" >/dev/null; then
            echo "::error::子模块远端不存在分支 origin/${DETECTED_BRANCH}"
            exit 1
          fi
          git -C "${SM_PATH}" checkout -B "${DETECTED_BRANCH}" "origin/${DETECTED_BRANCH}"

          git add "${SM_PATH}"
          if ! git diff --cached --quiet; then
            git commit -m "chore: bump submodule ${SM_PATH} to origin/${DETECTED_BRANCH} latest"
          fi

      # 替换 admin URL（排除子模块目录）
      - name: Replace admin HTTPS URLs (exclude submodule)
        run: |
          set -euo pipefail

          hit_count=$(git grep -n -E 'https://admin\.rustdesk\.com' -- ':!:libs/hbb_common' | wc -l || true)
          echo "admin.rustdesk.com 命中行数（排除子模块）: ${hit_count}"

          files_http=$(git grep -l -E 'https://admin\.rustdesk\.com' -- ':!:libs/hbb_common' || true)
          if [ -n "${files_http}" ]; then
            new_esc=${ADMIN_URL//&/\\&}
            echo "${files_http}" | xargs -r sed -i -e "s|https://admin\.rustdesk\.com|${new_esc}|g"
          fi

          if ! git diff --quiet; then
            git add -A
            git commit -m "chore: replace default admin HTTPS URL"
          else
            echo "没有发现需要替换或内容已是目标值。"
          fi

          remain=$(git grep -n -E 'https://admin\.rustdesk\.com' -- ':!:libs/hbb_common' | wc -l || true)
          echo "替换后残留 admin.rustdesk.com 行数（排除子模块）: ${remain}"

      # 替换 download URL（排除子模块）
      - name: Replace download URLs (exclude submodule)
        run: |
          set -euo pipefail

          hit_count=$(git grep -n -E 'https://rustdesk\.com/download' -- ':!:libs/hbb_common' | wc -l || true)
          echo "rustdesk.com/download 命中行数（排除子模块）: ${hit_count}"

          files_dl=$(git grep -l -E 'https://rustdesk\.com/download' -- ':!:libs/hbb_common' || true)
          if [ -n "${files_dl}" ]; then
            new_esc=${DOWNLOAD_URL//&/\\&}
            echo "${files_dl}" | xargs -r sed -i -e "s|https://rustdesk\.com/download|${new_esc}|g"
          fi

          if ! git diff --quiet; then
            git add -A
            git commit -m "chore: replace default download URL"
          else
            echo "没有发现需要替换下载地址或内容已是目标值。"
          fi

          remain=$(git grep -n -E 'https://rustdesk\.com/download' -- ':!:libs/hbb_common' | wc -l || true)
          echo "替换后残留 rustdesk.com/download 行数（排除子模块）: ${remain}"

      # （可选）推送分支
      - name: Push branch (optional)
        if: ${{ inputs.push_branch == 'true' }}
        run: |
          set -euo pipefail
          if [ "${{ inputs.force }}" = "true" ]; then
            git push --force-with-lease origin "HEAD:refs/heads/${WORK_BRANCH}"
          else
            git push origin "HEAD:refs/heads/${WORK_BRANCH}"
          fi

      # 打 Tag：锚定“分支HEAD”
      - name: Create/retarget tag at branch HEAD (verified)
        if: ${{ inputs.do_tag == 'true' }}
        id: tag_step
        run: |
          set -euo pipefail

          TAG_IN='${{ inputs.version }}'
          TAG="$TAG_IN"
          if [ -z "$TAG" ]; then TAG="${WORK_BRANCH}"; fi

          MSG='${{ inputs.tag_message }}'
          FORCE='${{ inputs.force }}'
          RETAG='${{ inputs.retag }}'
          PUSH_BRANCH='${{ inputs.push_branch }}'

          BRANCH_REF="refs/heads/${WORK_BRANCH}"
          LOCAL_BRANCH_SHA="$(git rev-parse "${BRANCH_REF}^{commit}")"
          echo "Local ${BRANCH_REF} HEAD: ${LOCAL_BRANCH_SHA}"

          # （按需）先删远端同名 Tag
          if [ "$RETAG" = "true" ]; then
            git push origin ":refs/tags/${TAG}" || true
          fi

          # 删除本地旧 Tag 并在本地分支 HEAD 上重建注释 Tag
          git tag -d "${TAG}" 2>/dev/null || true
          if [ "$FORCE" = "true" ]; then
            git tag -a -f "${TAG}" -m "${MSG}" "${LOCAL_BRANCH_SHA}"
          else
            git tag -a "${TAG}" -m "${MSG}" "${LOCAL_BRANCH_SHA}"
          fi

          # 推送 Tag
          git push origin "refs/tags/${TAG}"

          # 解析远端 Tag 指向的“提交 SHA”（处理注释Tag的剥离）
          REMOTE_TAG_OBJ_SHA="$(git ls-remote --tags origin "refs/tags/${TAG}"       | awk '{print $1}')"
          REMOTE_TAG_PEELED_SHA="$(git ls-remote --tags origin "refs/tags/${TAG}^{}" | awk '{print $1}')"
          if [ -n "${REMOTE_TAG_PEELED_SHA}" ]; then
            REMOTE_COMMIT_SHA="${REMOTE_TAG_PEELED_SHA}"
          else
            REMOTE_COMMIT_SHA="${REMOTE_TAG_OBJ_SHA}"
          fi
          echo "Remote Tag Peeled Commit: ${REMOTE_COMMIT_SHA:-<none>}"

          # 校验 1：远端 Tag 一定要指向“本地刚打的 commit”
          if [ -z "${REMOTE_COMMIT_SHA}" ] || [ "${REMOTE_COMMIT_SHA}" != "${LOCAL_BRANCH_SHA}" ]; then
            echo "::error::校验失败：远端Tag ${TAG}（${REMOTE_COMMIT_SHA:-<none>}）未指向本地分支HEAD（${LOCAL_BRANCH_SHA}）。"
            exit 1
          fi

          # 校验 2：如果你选择推分支，再校验“远端分支 HEAD == 远端 Tag 指向”
          if [ "$PUSH_BRANCH" = "true" ]; then
            REMOTE_BRANCH_SHA="$(git ls-remote origin "refs/heads/${WORK_BRANCH}" | awk '{print $1}')"
            echo "Remote refs/heads/${WORK_BRANCH}: ${REMOTE_BRANCH_SHA}"
            if [ -z "${REMOTE_BRANCH_SHA}" ] || [ "${REMOTE_BRANCH_SHA}" != "${REMOTE_COMMIT_SHA}" ]; then
              echo "::error::校验失败：远端Tag ${TAG}（${REMOTE_COMMIT_SHA}）未指向远端分支 ${WORK_BRANCH} 的HEAD（${REMOTE_BRANCH_SHA:-<none>}）。"
              exit 1
            fi
          else
            echo "push_branch=false：跳过“远端分支HEAD一致性”校验（仅保证 Tag 指向本次 commit）。"
          fi

          echo "tag_name=${TAG}" >> "$GITHUB_OUTPUT"

      - name: Show final refs and snippet
        run: |
          set -euo pipefail
          echo "---- Local refs/heads/${WORK_BRANCH} ----"
          git show -s --format="Commit %H%nDate   %ad%n%n%s" "refs/heads/${WORK_BRANCH}"

          if [ -f "src/common.rs" ]; then
            echo "---- src/common.rs 关键行（确认替换：仅显示命中，不打印 secrets） ----"
            (grep -nE 'admin\.rustdesk\.com|rustdesk\.com/download' src/common.rs || true) | head -n 80
          fi

          if [ "${{ inputs.do_tag }}" = "true" ]; then
            TAG_IN='${{ inputs.version }}'
            TAG="$TAG_IN"; if [ -z "$TAG" ]; then TAG="${WORK_BRANCH}"; fi
            echo "---- Remote Tag ${TAG} (peeled if annotated) ----"
            git show -s --format="Commit %H%nDate   %ad%n%n%s" "refs/tags/${TAG}^{}" || git show -s --format="Commit %H%nDate   %ad%n%n%s" "refs/tags/${TAG}"
          fi
