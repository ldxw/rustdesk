name: 从上游标签或master分支创建版本分支

on:
  workflow_dispatch:
    inputs:
      source_type:
        description: "源类型 (tag = 使用上游标签, master_branch = 使用上游master分支)"
        required: true
        type: choice
        options:
          - "tag"
          - "master_branch"
        default: "tag"
      version:
        description: "上游 Tag（如 1.4.1，仅当源类型为tag时有效）"
        required: false
        default: "1.4.1"
      force:
        description: "强制覆盖同名远端分支"
        required: true
        type: boolean
        default: false
      upstream_repo:
        description: "上游仓库（owner/repo）"
        required: true
        default: "rustdesk/rustdesk"
      target_directory:
        description: "本地存放目录（仅当源类型为master_branch时有效，默认latest）"
        required: false
        default: "latest"

permissions:
  contents: write

jobs:
  validate_inputs:
    runs-on: ubuntu-latest
    outputs:
      valid: ${{ steps.check.outputs.valid }}
      target_branch: ${{ steps.check.outputs.target_branch }}
      target_dir: ${{ steps.check.outputs.target_dir }}
    steps:
      - id: check
        run: |
          set -euo pipefail
          SOURCE_TYPE="${{ github.event.inputs.source_type }}"
          VERSION="${{ github.event.inputs.version }}"
          TARGET_DIR="${{ github.event.inputs.target_directory }}"
          
          # 验证输入
          if [ "$SOURCE_TYPE" = "tag" ] && [ -z "$VERSION" ]; then
            echo "::error::当源类型为tag时，版本号不能为空"
            echo "valid=false" >> "$GITHUB_OUTPUT"
            exit 1
          fi
          
          if [ "$SOURCE_TYPE" = "master_branch" ] && [ -z "$TARGET_DIR" ]; then
            echo "::error::当源类型为master_branch时，目标目录不能为空"
            echo "valid=false" >> "$GITHUB_OUTPUT"
            exit 1
          fi
          
          # 确定目标分支：
          # - 标签模式：使用标签名作为分支名
          # - master分支模式：固定使用"latest"作为本地分支名
          if [ "$SOURCE_TYPE" = "tag" ]; then
            echo "target_branch=$VERSION" >> "$GITHUB_OUTPUT"
          else
            echo "target_branch=latest" >> "$GITHUB_OUTPUT"
          fi
          
          echo "target_dir=$TARGET_DIR" >> "$GITHUB_OUTPUT"
          echo "valid=true" >> "$GITHUB_OUTPUT"

  create_version_branch:
    needs: validate_inputs
    if: ${{ needs.validate_inputs.outputs.valid == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout fork (this repo) without persisting credentials
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Configure git identity & remove App extraheader
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config --global --unset-all http.https://github.com/.extraheader || true

      - name: Add upstream & fetch source
        id: fetch_source
        run: |
          set -euo pipefail
          SOURCE_TYPE="${{ github.event.inputs.source_type }}"
          VERSION="${{ github.event.inputs.version }}"
          UPSTREAM="${{ github.event.inputs.upstream_repo }}"
          TARGET_DIR="${{ needs.validate_inputs.outputs.target_dir }}"
          TARGET_BRANCH="${{ needs.validate_inputs.outputs.target_branch }}"
          
          # 明确区分：
          # - 上游默认分支：master（从上游仓库拉取）
          # - 本地目标分支：latest（存储上游master分支内容）
          if [ "$SOURCE_TYPE" = "tag" ]; then
            SOURCE_REF="refs/tags/${VERSION}"
            FETCH_REF="refs/tags/upstream-${VERSION}"
          else
            SOURCE_REF="refs/heads/master"  # 上游默认分支为master
            FETCH_REF="refs/remotes/upstream/master"
          fi

          git remote add upstream "https://github.com/${UPSTREAM}.git" || true
          
          if [ "$SOURCE_TYPE" = "tag" ]; then
            git fetch --depth=1 upstream "${SOURCE_REF}:${FETCH_REF}" \
            || git fetch upstream "${SOURCE_REF}:${FETCH_REF}"
          else
            # 拉取上游master分支最新内容
            git fetch upstream master
          fi

          # 获取对应提交的SHA值
          if [ "$SOURCE_TYPE" = "tag" ]; then
            SHA="$(git rev-list -n 1 "${FETCH_REF}")"
          else
            # 从上游master分支获取最新提交
            SHA="$(git rev-parse upstream/master)"
          fi
          
          if [ -z "$SHA" ]; then
            echo "::error::上游 ${UPSTREAM} 不存在指定的源"
            exit 1
          fi
          
          echo "sha=$SHA" >> "$GITHUB_OUTPUT"
          echo "target_branch=$TARGET_BRANCH" >> "$GITHUB_OUTPUT"
          echo "target_dir=$TARGET_DIR" >> "$GITHUB_OUTPUT"

          if git ls-tree -r --name-only "$SHA" | grep -q '^.github/workflows/'; then
            echo "has_workflows=true"  >> "$GITHUB_OUTPUT"
          else
            echo "has_workflows=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Ensure PAT if workflows exist in the source
        if: ${{ steps.fetch_source.outputs.has_workflows == 'true' }}
        env:
          PAT: ${{ secrets.REPO_WORKFLOW_PAT }}
        run: |
          if [ -z "$PAT" ]; then
            echo "::error::该源包含 .github/workflows/*。请配置 REPO_WORKFLOW_PAT"
            exit 1
          fi

      - name: Use PAT for push (override origin)
        env:
          PAT: ${{ secrets.REPO_WORKFLOW_PAT }}
        run: |
          if [ -n "$PAT" ]; then
            git remote set-url origin "https://${PAT}@github.com/${GITHUB_REPOSITORY}.git"
            echo "Using PAT to push."
          else
            echo "Using default push (no PAT)."
          fi

      - name: Skip if remote branch exists and not forcing
        id: exists_check
        run: |
          set -euo pipefail
          TARGET_BRANCH="${{ steps.fetch_source.outputs.target_branch }}"
          FORCE="${{ github.event.inputs.force }}"
          
          if git ls-remote --exit-code --heads origin "refs/heads/${TARGET_BRANCH}" >/dev/null 2>&1; then
            if [ "$FORCE" = "true" ]; then
              echo "exists=true"  >> "$GITHUB_OUTPUT"
              echo "skip=false"   >> "$GITHUB_OUTPUT"
              echo "force=true"   >> "$GITHUB_OUTPUT"
              echo "同名远端分支已存在，启用强制覆盖。"
            else
              echo "exists=true"  >> "$GITHUB_OUTPUT"
              echo "skip=true"    >> "$GITHUB_OUTPUT"
              echo "force=false"  >> "$GITHUB_OUTPUT"
              echo "同名远端分支已存在，未启用强制，跳过。"
            fi
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
            echo "skip=false"   >> "$GITHUB_OUTPUT"
            echo "force=${FORCE}" >> "$GITHUB_OUTPUT"
          fi

      - name: Delete remote branch if forcing
        if: ${{ steps.exists_check.outputs.skip == 'false' && steps.exists_check.outputs.force == 'true' }}
        run: |
          TARGET_BRANCH="${{ steps.fetch_source.outputs.target_branch }}"
          git push origin ":refs/heads/${TARGET_BRANCH}" 2>/dev/null || true

      - name: Create/update local branch
        if: ${{ steps.exists_check.outputs.skip == 'false' }}
        run: |
          set -euo pipefail
          TARGET_BRANCH="${{ steps.fetch_source.outputs.target_branch }}"
          SHA="${{ steps.fetch_source.outputs.sha }}"
          # 对于master分支模式：创建/更新本地latest分支，内容与上游master分支一致
          git update-ref "refs/heads/${TARGET_BRANCH}" "$SHA"

      - name: Push branch to remote
        if: ${{ steps.exists_check.outputs.skip == 'false' }}
        run: |
          set -euo pipefail
          TARGET_BRANCH="${{ steps.fetch_source.outputs.target_branch }}"
          if git ls-remote --exit-code --heads origin "refs/heads/${TARGET_BRANCH}" >/dev/null 2>&1; then
            git push --force-with-lease origin "refs/heads/${TARGET_BRANCH}:refs/heads/${TARGET_BRANCH}"
          else
            git push origin "refs/heads/${TARGET_BRANCH}:refs/heads/${TARGET_BRANCH}"
          fi

      - name: Checkout to target directory
        if: ${{ steps.fetch_source.outputs.target_branch == 'latest' && steps.exists_check.outputs.skip == 'false' }}
        run: |
          set -euo pipefail
          # 本地latest分支内容来自上游master分支
          # 将latest分支内容检出到指定目录（默认latest目录）
          TARGET_BRANCH="latest"
          TARGET_DIR="${{ steps.fetch_source.outputs.target_dir }}"
          
          mkdir -p "${TARGET_DIR}"
          git --work-tree="${TARGET_DIR}" checkout "${TARGET_BRANCH}" -- .
          
          echo "已将上游master分支内容同步到本地latest分支，并检出到 ${TARGET_DIR} 目录"
