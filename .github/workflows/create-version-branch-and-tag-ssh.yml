name: 更新分支并打Tag：子模块 + URL替换 + Tag锚定分支HEAD

on:
  workflow_dispatch:
    inputs:
      work_branch:
        description: "要更新并打Tag的分支（例如 1.4.2）"
        required: true
        default: "1.4.2"
      # 仅替换 https://admin.rustdesk.com  
      admin_url:  
        description: "将仓库内所有 https://admin.rustdesk.com 替换为该地址（不改子模块内容）"  
        required: true  
        default: "https://admin-hy.rs.ldxw.top"  
      # 子模块（公开仓库，HTTPS）  
      submodule_url:  
        description: "libs/hbb_common 子模块公开仓库（HTTPS）地址"  
        required: true  
        default: "https://github.com/ldxw/rustdesk_hbb_common.git"  
      submodule_branch:  
        description: "libs/hbb_common 子模块分支（auto=自动检测远端默认分支）"  
        required: true  
        default: "auto"  
      # 推分支与打Tag选项（≤10个）  
      push_branch:  
        description: "是否推送分支（true=推；false=只本地更改）"  
        type: choice  
        options: ["true", "false"]  
        required: true  
        default: "true"  
      force:  
        description: "推分支/建Tag是否强制（分支用 --force-with-lease；Tag 用 -f）"  
        type: choice  
        options: ["false", "true"]  
        required: true  
        default: "false"  
      do_tag:  
        description: "是否在分支HEAD打Tag"  
        type: choice  
        options: ["true", "false"]  
        required: true  
        default: "true"  
      version:  
        description: "Tag 名（留空使用 work_branch）"  
        required: false  
        default: ""  
      tag_message:  
        description: "Tag 注释"  
        required: false  
        default: "修改内置服务器和 key"  
      retag:  
        description: "是否强制重打Tag（先删远端同名Tag再建）"  
        type: choice  
        options: ["true", "false"]  
        required: true  
        default: "true"

permissions:
  contents: write  # 明确授予内容写入权限，避免推送/打Tag权限不足

jobs:
  update_and_tag:
    runs-on: ubuntu-latest
    env:
      WORK_BRANCH: ${{ inputs.work_branch }}
      SM_PATH: "libs/hbb_common"  # 子模块路径统一定义为环境变量，避免重复编写
      TARGET_OLD_URL: "https://admin.rustdesk.com"  # 待替换旧URL统一定义，便于维护
    steps:
      # 步骤1：拉取仓库代码（补充fetch-depth=0确保完整历史，适配分支切换）
      - name: Checkout repo (with full history, no persisted creds)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # 拉取完整提交历史，避免分支切换时缺失远端记录
          persist-credentials: false  # 关闭默认凭证持久化，后续手动配置
          submodules: false  # 暂不拉取子模块，后续步骤单独处理，便于控制流程

      # 步骤2：配置Git身份（补充容错，避免身份配置失败）
      - name: Configure Git identity
        run: |
          set -euo pipefail  # 开启严格模式，报错立即终止，避免后续无效执行
          echo -e "\n=================================================="
          echo -e "🔧 配置Git提交身份（适配GitHub Actions规范）"
          echo -e "==================================================\n"
          
          # 配置Git用户信息，使用官方bot账号，避免提交者身份异常
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          
          # 校验配置结果，确保身份配置生效
          config_name=$(git config --global user.name)
          config_email=$(git config --global user.email)
          if [ "${config_name}" = "github-actions[bot]" ] && [ "${config_email}" = "41898282+github-actions[bot]@users.noreply.github.com" ]; then
            echo "✅ Git身份配置成功：name=${config_name}，email=${config_email}"
          else
            echo -e "\n::error::❌ Git身份配置失败，当前name=${config_name:-空}，email=${config_email:-空}"
            exit 1
          fi

      # 步骤3：本地准备目标分支（新增分支存在性双重校验，优化错误提示）
      - name: Prepare target branch locally
        run: |
          set -euo pipefail
          echo -e "\n=================================================="
          echo -e "📦 本地初始化目标分支：${WORK_BRANCH}"
          echo -e "📌 流程：拉取远端分支 → 校验存在性 → 本地切换/创建"
          echo -e "==================================================\n"
          
          # 拉取远端所有分支（不含Tag），确保本地获取最新远端分支列表
          echo "🔍 拉取远端最新分支信息..."
          git fetch origin --no-tags
          if [ $? -ne 0 ]; then  # 校验fetch命令执行结果，避免静默失败
            echo -e "\n::error::❌ 拉取远端分支失败，请检查仓库连接或权限"
            exit 1
          fi
          echo "✅ 远端分支信息拉取完成"

          # 校验远端目标分支是否存在
          if ! git show-ref --verify --quiet "refs/remotes/origin/${WORK_BRANCH}"; then
            echo -e "\n::error::❌ 远端仓库不存在分支「origin/${WORK_BRANCH}」"
            echo "ℹ️ 建议检查：1. 分支名是否拼写正确；2. 分支是否已推送到远端"
            exit 1
          fi
          echo "✅ 远端目标分支「origin/${WORK_BRANCH}」存在"

          # 处理本地分支：存在则切换+快速合并，不存在则基于远端创建
          if git show-ref --verify --quiet "refs/heads/${WORK_BRANCH}"; then
            # 本地已存在分支，切换后执行快速合并（避免冲突）
            git checkout "refs/heads/${WORK_BRANCH}"
            echo "ℹ️ 本地已存在分支「${WORK_BRANCH}」，执行远端更新合并"
            if ! git merge --ff-only "refs/remotes/origin/${WORK_BRANCH}"; then
              echo -e "\n::warning::⚠️ 快速合并失败，可能存在本地未推送修改"
              echo "ℹ️ 处理建议：1. 手动同步本地修改；2. 确认是否需要保留本地修改"
              exit 1
            fi
            echo "✅ 本地分支「${WORK_BRANCH}」已同步远端最新更新"
          else
            # 本地不存在分支，基于远端分支创建新分支
            git checkout -B "${WORK_BRANCH}" "refs/remotes/origin/${WORK_BRANCH}"
            echo "✅ 本地已创建分支「${WORK_BRANCH}」，基于远端「origin/${WORK_BRANCH}」"
          fi

      # 步骤4：配置并更新子模块（新增子模块版本校验，优化错误容错）
      - name: Configure and update submodule
        id: sm_update
        run: |
          set -euo pipefail
          SM_NAME="libs/hbb_common"
          SM_URL="${{ inputs.submodule_url }}"
          REQ_BRANCH="${{ inputs.submodule_branch }}"

          echo -e "\n=================================================="
          echo -e "🔗 子模块配置与更新（目标子模块：${SM_PATH}）"
          echo -e "📌 子模块仓库：${SM_URL}"
          echo -e "📌 目标分支（输入）：${REQ_BRANCH}"
          echo -e "==================================================\n"

          # 校验.gitmodules文件是否存在（子模块配置基础）
          if [ ! -f ".gitmodules" ]; then
            echo -e "\n::error::❌ 项目根目录缺失「.gitmodules」文件，未声明子模块"
            echo "ℹ️ 处理建议：1. 确认项目是否包含子模块；2. 检查.gitmodules文件是否被误删"
            exit 1
          fi
          echo "✅ 检测到「.gitmodules」文件，开始子模块配置"

          # 处理子模块分支：自动检测（输入为auto或分支不存在时）/使用指定分支
          DETECTED_BRANCH="${REQ_BRANCH}"
          if [ "${REQ_BRANCH}" = "auto" ] || ! git ls-remote --heads "${SM_URL}" "${REQ_BRANCH}" | grep -q "."; then
            echo "🔍 自动检测子模块远端默认分支..."
            # 解析子模块远端HEAD指向的分支（适配不同仓库默认分支命名）
            DETECTED_BRANCH=$(git ls-remote --symref "${SM_URL}" HEAD | awk '/^ref:/ {print $2}' | sed 's#refs/heads/##')
            # 校验自动检测结果，避免分支为空
            if [ -z "${DETECTED_BRANCH}" ]; then
              echo -e "\n::error::❌ 自动检测子模块默认分支失败"
              echo "ℹ️ 处理建议：1. 确认子模块仓库是否有默认分支；2. 手动指定submodule_branch参数"
              exit 1
            fi
            echo "✅ 自动检测到子模块默认分支：${DETECTED_BRANCH}"
          else
            echo "✅ 子模块远端存在指定分支「${REQ_BRANCH}」，无需自动检测"
          fi
          # 输出检测到的子模块分支，供后续步骤使用
          echo "sm_branch=${DETECTED_BRANCH}" >> "$GITHUB_OUTPUT"

          # 配置子模块.gitmodules信息（URL、路径、分支）
          git config -f .gitmodules "submodule.${SM_NAME}.url" "${SM_URL}"
          git config -f .gitmodules "submodule.${SM_NAME}.path" "${SM_PATH}"
          git config -f .gitmodules "submodule.${SM_NAME}.branch" "${DETECTED_BRANCH}"
          git add .gitmodules  # 暂存.gitmodules修改

          # 提交.gitmodules配置（仅当有变更时）
          if ! git diff --cached --quiet; then
            git commit -m "chore(submodule): configure ${SM_PATH} to ${SM_URL} (branch: ${DETECTED_BRANCH})"
            echo "✅ 已提交「.gitmodules」配置修改"
          else
            echo "ℹ️ 「.gitmodules」配置无变更，无需提交"
          fi

          # 同步子模块配置并更新内容（避免旧配置残留）
          echo -e "\n🚀 开始同步子模块配置与内容..."
          git submodule sync -- "${SM_PATH}"  # 同步.gitmodules配置到子模块
          git submodule set-url "${SM_PATH}" "${SM_URL}" || true  # 强制设置子模块URL
          git submodule set-branch --branch "${DETECTED_BRANCH}" "${SM_PATH}" || true  # 强制设置子模块分支
          # 初始化并拉取子模块远端最新内容（--remote确保拉取目标分支最新）
          git submodule update --init --remote "${SM_PATH}"
          if [ $? -ne 0 ]; then
            echo -e "\n::error::❌ 子模块内容更新失败"
            echo "ℹ️ 处理建议：1. 检查子模块仓库URL是否有效；2. 确认网络连接正常"
            exit 1
          fi
          echo "✅ 子模块配置同步与内容拉取完成"

          # 校验子模块分支并切换（确保子模块处于目标分支）
          git -C "${SM_PATH}" fetch origin --no-tags  # 拉取子模块远端分支信息
          if ! git -C "${SM_PATH}" rev-parse --verify -q "refs/remotes/origin/${DETECTED_BRANCH}" >/dev/null; then
            echo -e "\n::error::❌ 子模块远端不存在分支「origin/${DETECTED_BRANCH}」"
            exit 1
          fi
          # 子模块切换到目标分支（创建本地分支，避免处于detached HEAD状态）
          git -C "${SM_PATH}" checkout -B "${DETECTED_BRANCH}" "origin/${DETECTED_BRANCH}"
          echo "✅ 子模块已切换至目标分支：${DETECTED_BRANCH}"

          # 提交子模块指针更新（子模块版本变更时）
          git add "${SM_PATH}"
          if ! git diff --cached --quiet; then
            git commit -m "chore(submodule): bump ${SM_PATH} to origin/${DETECTED_BRANCH} (latest commit)"
            echo "✅ 已提交子模块指针更新，同步至远端最新版本"
          else
            echo "ℹ️ 子模块已为远端最新版本，无需提交指针更新"
          fi

      # 步骤5：替换admin HTTPS URL（隐藏新域名，新增替换前后校验）
      - name: Replace admin HTTPS URL (exclude submodule)
        run: |
          set -euo pipefail
          NEW_URL="${{ inputs.admin_url }}"
          replace_file_count=0  # 统计替换文件数量，用于日志与commit信息

          echo -e "\n=================================================="
          echo -e "🔄 执行admin URL替换（排除子模块：${SM_PATH}）"
          echo -e "📌 待替换旧URL：${TARGET_OLD_URL}"
          echo -e "📌 替换策略：不暴露新URL，仅批量替换有效文件"
          echo -e "==================================================\n"

          # 1. 检测需替换的文件（排除子模块，避免修改子模块内容）
          echo "🔍 检测含旧URL「${TARGET_OLD_URL}」的文件..."
          files_http=$(git grep -l -E "${TARGET_OLD_URL}" -- ":!:${SM_PATH}" || true)
          # 统计替换文件数量（处理空值，避免wc命令统计错误）
          if [ -n "${files_http}" ]; then
            replace_file_count=$(echo "${files_http}" | wc -w)
            echo "✅ 检测到 ${replace_file_count} 个文件需替换，文件列表："
            # 格式化输出文件列表（每行1个，清晰易读）
            echo "${files_http}" | tr ' ' '\n' | awk '{print "   - " $0}'
          else
            echo "ℹ️ 未检测到含旧URL「${TARGET_OLD_URL}」的文件，无需替换"
            # 直接跳过后续替换逻辑，避免无效执行
            return 0
          fi

          # 2. 执行URL替换（转义&等特殊字符，避免sed命令报错）
          echo -e "\n🚀 开始执行URL替换（共 ${replace_file_count} 个文件）..."
          new_esc="${NEW_URL//&/\\&}"  # 转义URL中的&字符，适配sed语法
          echo "${files_http}" | xargs -r sed -i -e "s|${TARGET_OLD_URL}|${new_esc}|g"
          if [ $? -ne 0 ]; then
            echo -e "\n::error::❌ URL替换执行失败，可能存在特殊字符未处理"
            exit 1
          fi
          echo "✅ URL替换完成，所有目标文件已更新"

          # 3. 预览关键文件替换结果（src/common.rs为核心配置文件，优先校验）
          if [ -f "src/common.rs" ]; then
            echo -e "\n=================================================="
            echo -e "📄 关键文件预览：src/common.rs（替换后相关行）"
            echo -e "==================================================\n"
            # 预览替换后关键内容（排除旧URL残留，显示新URL特征）
            preview_result=$(grep -nE "rs\.ldxw\.top|admin-hy" "src/common.rs" || echo "   该文件无相关关键行")
            echo "${preview_result}" | head -n 50 | awk '{print "   " $0}'  # 限制预览行数，避免日志过长
            echo -e "==================================================\n"
          fi

          # 4. 提交URL替换修改（commit信息不含新域名，保护隐私）
          if ! git diff --quiet; then
            git add -A  # 暂存所有修改文件
            git commit -m "chore(url): update admin HTTPS URL (total ${replace_file_count} files)"
            echo "📝 已提交URL替换修改，commit信息：chore(url): update admin HTTPS URL (total ${replace_file_count} files)"
          else
            echo "ℹ️ 无URL替换相关变更，无需提交"
          fi

          # 5. 替换后残留检测（确保旧URL
